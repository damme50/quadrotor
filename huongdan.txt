1/ I2C1  Read data from MPU6050 (sensor 10 truc)
MPU6050     STM32Fxxx     Descrption
 
SCL         PB6           Clock line for I2C
SDA         PB7           Data line for I2C
IRQ         -             User selectable pin if needed. Interrupts for STM must be manually enabled by user.
VCC         3.3V
GND         GND
AD0         -             If pin is low, I2C address is 0xD0, if pin is high, the address is 0xD2
-----------------------------------------------------------
		B1: address = 0xD0
		B2: init I2C tren I2C1 and set clock rate
		B3: start I2C1
		B4: check connected
			if (HAL_I2C_IsDeviceReady(Handle, device_address = 0xD0, 2, 5) != HAL_OK) 
			{
			}

		B5: get Who I Am value
				address = device_address = 0xD0
				#define MPU6050_WHO_AM_I			0x75 //register_address
				#define MPU6050_I_AM_VALUES		0x68
				uint8_t temp;

				-----transmit/receiver---
			TM_I2C_Result_t TM_I2C_Read(I2C_HandleTypeDef* Handle, uint8_t device_address, uint8_t register_address, uint8_t* data) 
			{
				/* Send address */
				if (HAL_I2C_Master_Transmit(Handle, (uint16_t)device_address, &register_address, 1, 1000) != HAL_OK) {
					/* Check error */
					if (HAL_I2C_GetError(Handle) != HAL_I2C_ERROR_AF) {}
					/* Return error */
					return TM_I2C_Result_Error;
				}
				
				/* Receive multiple byte */
				if (HAL_I2C_Master_Receive(Handle, device_address, data, 1, 1000) != HAL_OK) {
					/* Check error */
					if (HAL_I2C_GetError(Handle) != HAL_I2C_ERROR_AF) {}
					/* Return error */
					return TM_I2C_Result_Error;
				}
				return OK;
			}

		B6: wake up MPU6050
			address = device_address = 0xD0
			#define MPU6050_PWR_MGMT_1			0x6B  //register_address
			data = 0x00 

			TM_I2C_Result_t TM_I2C_Write(I2C_HandleTypeDef* Handle, uint8_t device_address, uint8_t register_address, uint8_t data) 
			{
				uint8_t d[2];
					
				/* Format array to send */
				d[0] = register_address;
				d[1] = data;
				
				/* Try to transmit via I2C */
				if (HAL_I2C_Master_Transmit(Handle, (uint16_t)device_address, (uint8_t *)d, 2, 1000) != HAL_OK) 
				{
					/* Check error */
					if (HAL_I2C_GetError(Handle) != HAL_I2C_ERROR_AF) {}
					/* Return error */
					return TM_I2C_Result_Error;
				} 
				/* Return OK */
				return TM_I2C_Result_Ok;
			}

		B7: set data rate	
			address = device_address = 0xD0	
			#define MPU6050_SMPLRT_DIV			0x19 //register
			#define TM_MPU6050_DataRate_1KHz       7  //rate /*!< Sample rate set to 1 kHz */

			TM_MPU6050_Result_t TM_MPU6050_SetDataRate(I2C_HandleTypeDef* Handle, uint8_t device_address, uint8_t register_address, uint8_t rate) 
			{
				uint8_t d[2];
				/* Format array to send */
				d[0] = register_address;
				d[1] = rate;
				/* Try to transmit via I2C */
				if (HAL_I2C_Master_Transmit(Handle, (uint16_t)device_address, (uint8_t *)d, 2, 1000) != HAL_OK) 
				{
					if (HAL_I2C_GetError(Handle) != HAL_I2C_ERROR_AF) {}
					return TM_I2C_Result_Error;
				} 
				/* Return OK */
				return TM_I2C_Result_Ok;
			}

		B8: Set Accelerometer 
			TM_MPU6050_Accelerometer_8G = 0x02, /*!< Range is +- 8G */
			MPU6050_ACCEL_CONFIG //#define MPU6050_ACCEL_CONFIG		0x1C


			uint8_t temp;			
			/* Config accelerometer */
			TM_I2C_Read(MPU6050_I2C, DataStruct->Address, MPU6050_ACCEL_CONFIG, &temp);
			temp = (temp & 0xE7) | (uint8_t)TM_MPU6050_Accelerometer_8G << 3;
			TM_I2C_Write(MPU6050_I2C, DataStruct->Address, MPU6050_ACCEL_CONFIG, temp);
			/* Set sensitivities for multiplying gyro and accelerometer data */
			switch (AccelerometerSensitivity) {
				case TM_MPU6050_Accelerometer_2G:
					DataStruct->Acce_Mult = (float)1 / MPU6050_ACCE_SENS_2; 
					break;
				case TM_MPU6050_Accelerometer_4G:
					DataStruct->Acce_Mult = (float)1 / MPU6050_ACCE_SENS_4; 
					break;
				case TM_MPU6050_Accelerometer_8G:
					DataStruct->Acce_Mult = (float)1 / MPU6050_ACCE_SENS_8; 
					break;
				case TM_MPU6050_Accelerometer_16G:
					DataStruct->Acce_Mult = (float)1 / MPU6050_ACCE_SENS_16; 
				default:
					break;
			}
			
			/* Return OK */
			return TM_MPU6050_Result_Ok;
		B9: Set Gyro
		B10: Read data 


-------------------------------------------------------------------------------------
2/ PWM + TIMER3